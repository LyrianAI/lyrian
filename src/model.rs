//! A module related to the lyric generation.

use crate::lyric::Lyric;
use crate::markov::MarkovModel;
use crate::morphological_analysis::{tokenize, LyrianToken};
use serde::{Deserialize, Serialize};

/// The structure of generating lyric.
#[derive(Serialize, Deserialize)]
pub struct LyrianModel {
    markov: MarkovModel<LyrianToken>,
}

impl<'a> LyrianModel {
    /// Creates a new instance of [`LyrianModel`].
    fn new(markov_model: MarkovModel<LyrianToken>) -> LyrianModel {
        LyrianModel {
            markov: markov_model,
        }
    }

    /// Builds a new model from text data.
    ///
    /// Creates a [`LyrianModel`] by splitting text data into tokens and building a [`MarkovModel`]
    /// from them.
    pub fn from_str(contents: &str) -> Result<LyrianModel, String> {
        let tokens = tokenize(contents)?;
        let markov_model = MarkovModel::<LyrianToken>::from(tokens);
        let lyr_model = LyrianModel::new(markov_model);
        Ok(lyr_model)
    }

    /// Builds a new model from json data.
    ///
    /// The json data is generated by [`to_json_str()`](#method.to_json_str) method.
    pub fn from_json(json: &'a str) -> Result<LyrianModel, String> {
        match serde_json::from_str::<'a, MarkovModel<LyrianToken>>(json) {
            Ok(markov_model) => {
                let lyr_model = LyrianModel::new(markov_model);
                Ok(lyr_model)
            }
            Err(e) => Err(e.to_string()),
        }
    }

    /// Generates lyric.
    ///
    /// The lyric information is returned by [`Lyric`].
    ///
    /// The return value will be changed by the following arguments.
    ///
    /// - syllable: [`bool`]
    ///     - Will calculate the number by syllable unit.
    /// - voiceless: [`bool`] (unimplemented)
    ///     - Will not count voiceless sounds, like "ク" in "サクラ".
    /// - smoothly: [`bool`] (unimplemented)
    ///     - Will not count smoothly connected vowel sounds.
    ///     - For example, the "イ" in "ダイチ" will be counted as one sound "ダイ".
    pub fn generate_lyric(&mut self, lyric_len: usize, syllable: bool) -> Result<Lyric, String> {
        for _ in 0..64 {
            let mut lyric = Lyric::new(Vec::new());
            for _ in 0..64 {
                lyric.add_token(self.markov.next().clone());
                if lyric_len < lyric.length(syllable) {
                    break;
                } else if lyric_len == lyric.length(syllable) {
                    return Ok(lyric);
                }
            }
            self.markov.initialize();
        }

        Err(String::from(
            "Could not generate a lyric in given arguments.",
        ))
    }

    /// Converts the model to the json data.
    ///
    /// Use this to reduce computational costs and to correct words that are not
    /// in the corpus.
    pub fn to_json_str(&self) -> Result<String, String> {
        match serde_json::to_string(&self.markov) {
            Ok(v) => Ok(v),
            Err(e) => Err(e.to_string()),
        }
    }
}
