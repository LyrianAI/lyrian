//! Lyric generation with Markov chain.

use crate::lyric::Lyric;
use crate::morphological_analysis::{tokenize, LyrianToken};
use markov_rs::MarkovChain;
use serde::{Deserialize, Serialize};

/// The structure of generating lyric.
#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct LyrianModel {
    markov: MarkovChain<LyrianToken>,
}

impl<'a> LyrianModel {
    /// Creates a new instance of [`LyrianModel`].
    fn new(markov_model: MarkovChain<LyrianToken>) -> LyrianModel {
        LyrianModel {
            markov: markov_model,
        }
    }

    /// Builds a new model from text data.
    ///
    /// Creates a [`LyrianModel`] by splitting text data into tokens and building
    /// a markov chain model from them.
    pub fn from_str(contents: &str) -> Result<LyrianModel, String> {
        let tokens = tokenize(contents)?;
        let markov_model = MarkovChain::from(&tokens);
        let lyr_model = LyrianModel::new(markov_model);
        Ok(lyr_model)
    }

    /// Builds a new model from json data.
    ///
    /// The json data is generated by [`to_json_str()`](#method.to_json_str) method.
    pub fn from_json(json: &'a str) -> Result<LyrianModel, String> {
        match serde_json::from_str::<'a, MarkovChain<LyrianToken>>(json) {
            Ok(markov_model) => {
                let lyr_model = LyrianModel::new(markov_model);
                Ok(lyr_model)
            }
            Err(e) => Err(e.to_string()),
        }
    }

    /// Generates lyric.
    ///
    /// By specifying the number of notes, a word will be assigned to each of
    /// those notes.
    ///
    /// The way the words are assigned can be changed by setting the following
    /// variables.
    ///
    /// - syllable: [`bool`]
    ///     - Will calculate the number by syllable unit.
    ///
    /// If you set `false` to all the arguments, you will get a lyric assigned
    /// by mora unit.
    pub fn generate_lyric(&mut self, num_of_notes: usize, syllable: bool) -> Result<Lyric, String> {
        for _ in 0..64 {
            let mut lyric = Lyric::new(vec![self.get_first_token()]);
            for _ in 0..64 {
                if num_of_notes < lyric.length(syllable) {
                    break;
                } else if num_of_notes == lyric.length(syllable) {
                    return Ok(lyric);
                }
                lyric.add_token(self.markov.next().clone());
            }
            self.markov.initialize();
        }

        Err(String::from(
            "Could not generate a lyric in given arguments.",
        ))
    }

    /// Converts the model to the json data.
    ///
    /// Use this to reduce computational costs and to correct words that
    /// are not in the corpus.
    pub fn to_json_str(&self) -> Result<String, String> {
        match serde_json::to_string(&self.markov) {
            Ok(v) => Ok(v),
            Err(e) => Err(e.to_string()),
        }
    }

    // Gets a first token that is neither a particle nor an auxiliary verb.
    fn get_first_token(&mut self) -> LyrianToken {
        let mut token;
        loop {
            token = self.markov.next().clone();
            if token.part_of_speech != "助詞" && token.part_of_speech != "助動詞" {
                break;
            }
        }
        token
    }
}

#[cfg(test)]
mod model_test {
    use crate::model::LyrianModel;

    #[test]
    fn build_same_model_from_json() {
        let str_model = LyrianModel::from_str("もも").unwrap();
        let json = str_model.to_json_str().unwrap();
        let json_model = LyrianModel::from_json(&*json).unwrap();
        assert_eq!(json_model, str_model)
    }

    #[test]
    fn check_lyric_length() {
        let mut model = LyrianModel::from_str("すもももももももものうち").unwrap();
        let lyric_1 = model.generate_lyric(5, false).unwrap();
        let lyric_2 = model.generate_lyric(5, true).unwrap();

        assert_eq!((lyric_1.length(false), lyric_2.length(true)), (5, 5));
    }
}
