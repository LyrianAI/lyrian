//! A module related to the lyric generation.

use crate::lyric::Lyric;
use crate::markov::MarkovModel;
use crate::morphological_analysis::{tokenize, LyrianToken};
use serde::{Deserialize, Serialize};

/// The structure of generating lyric.
#[derive(Serialize, Deserialize, PartialEq, Debug)]
pub struct LyrianModel {
    markov: MarkovModel<LyrianToken>,
}

impl<'a> LyrianModel {
    /// Creates a new instance of [`LyrianModel`].
    fn new(markov_model: MarkovModel<LyrianToken>) -> LyrianModel {
        LyrianModel {
            markov: markov_model,
        }
    }

    /// Builds a new model from text data.
    ///
    /// Creates a [`LyrianModel`] by splitting text data into tokens and building
    /// a markov chain model from them.
    pub fn from_str(contents: &str) -> Result<LyrianModel, String> {
        let tokens = tokenize(contents)?;
        let markov_model = MarkovModel::<LyrianToken>::from(tokens);
        let lyr_model = LyrianModel::new(markov_model);
        Ok(lyr_model)
    }

    /// Builds a new model from json data.
    ///
    /// The json data is generated by [`to_json_str()`](#method.to_json_str) method.
    pub fn from_json(json: &'a str) -> Result<LyrianModel, String> {
        match serde_json::from_str::<'a, MarkovModel<LyrianToken>>(json) {
            Ok(markov_model) => {
                let lyr_model = LyrianModel::new(markov_model);
                Ok(lyr_model)
            }
            Err(e) => Err(e.to_string()),
        }
    }

    /// Generates lyric.
    ///
    /// By specifying the number of notes, a word will be assigned to each of
    /// those notes.
    ///
    /// The way the words are assigned can be changed by setting the following
    /// variables.
    ///
    /// - syllable: [`bool`]
    ///     - Will calculate the number by syllable unit.
    ///
    /// If you set `false` to all the arguments, you will get a lyric assigned
    /// by mora unit.
    pub fn generate_lyric(&mut self, num_of_notes: usize, syllable: bool) -> Result<Lyric, String> {
        for _ in 0..64 {
            let mut lyric = Lyric::new(Vec::new());
            for _ in 0..64 {
                lyric.add_token(self.markov.next().clone());
                if num_of_notes < lyric.length(syllable) {
                    break;
                } else if num_of_notes == lyric.length(syllable) {
                    return Ok(lyric);
                }
            }
            self.markov.initialize();
        }

        Err(String::from(
            "Could not generate a lyric in given arguments.",
        ))
    }

    /// Converts the model to the json data.
    ///
    /// Use this to reduce computational costs and to correct words that
    /// are not in the corpus.
    pub fn to_json_str(&self) -> Result<String, String> {
        match serde_json::to_string(&self.markov) {
            Ok(v) => Ok(v),
            Err(e) => Err(e.to_string()),
        }
    }
}

#[cfg(test)]
mod model_test {
    use crate::model::LyrianModel;

    #[test]
    fn build_same_model_from_json() {
        let str_model = LyrianModel::from_str("もも").unwrap();
        let json = str_model.to_json_str().unwrap();
        let json_model = LyrianModel::from_json(&*json).unwrap();
        assert_eq!(json_model, str_model)
    }
}
