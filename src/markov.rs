//! A module related to Markov chain and its model generation.

use crate::builder::WalkerBoxBuilder;
use crate::walkers_alias_method::WalkerBox;
use rand::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, PartialEq)]
/// Markov model structure
pub struct MarkovModel<T> {
    /// The set of possible states of the model.
    state_space: Vec<T>,

    /// The transition probability table by Walker's Alias Method.
    ///
    /// The head value is the index corresponding to the state of `state_space`, and the tail
    /// is the probability weights of it.
    ///
    /// The type of the weights is [`usize`] to counter floating point arithmetic errors.
    walker_boxes: Vec<WalkerBox>,

    /// The index of the state generated by the previous [`next()`](#method.next)
    /// method. The initial value is the length of `state_space`.
    prev_index: usize,
}

impl<T> MarkovModel<T>
where
    T: Clone,
    T: Eq,
    T: Ord,
    T: PartialOrd,
    T: PartialEq,
{
    /// Creates a new instance of [`MarkovModel`].
    fn new(state_space: Vec<T>, walker_boxes: Vec<WalkerBox>, prev_index: usize) -> MarkovModel<T> {
        MarkovModel {
            state_space: state_space,
            walker_boxes: walker_boxes,
            prev_index: prev_index,
        }
    }

    /// Builds a new model from [`Vec<T>`].
    pub fn from(elements: Vec<T>) -> MarkovModel<T> {
        let mut state_space = elements.clone();
        state_space.sort();
        state_space.dedup();

        let space_len = state_space.len();

        let mut freq_table = vec![vec![0; space_len]; space_len];
        let mut prev_index: Option<usize> = None;
        for element in elements {
            let cur_index = state_space
                .iter()
                .position(|state| element == *state)
                .expect("There is no state that should exist.");
            if let Some(i) = prev_index {
                freq_table[i][cur_index] += 1;
            }
            prev_index = Some(cur_index);
        }

        let mut walker_boxes = Vec::new();
        for row in freq_table {
            let mut builder = WalkerBoxBuilder::new(row);
            walker_boxes.push(builder.build());
        }

        MarkovModel::new(state_space, walker_boxes, space_len)
    }

    /// Returns the next possible state.
    ///
    /// The first state will be determined randomly, and the next one will be chosen
    /// by its state space.
    ///
    /// If you want to initialize the chain of states, use [`initialize()`](#method.initialize)
    /// methods.
    pub fn next(&mut self) -> &T {
        let elem_index = self.next_elem_index();
        self.prev_index = elem_index;
        self.state_space
            .get(elem_index)
            .expect("There is no state that should exist.")
    }

    /// Returns the index of the next output state.
    fn next_elem_index(&mut self) -> usize {
        let row = self.get_prev_index();
        self.walker_boxes[row].next()
    }

    /// Returns the index of the previous output state.
    ///
    /// If the value of `prev_index` is equal to the length of `state_space`, update it
    /// with a randomly generated value.
    ///
    /// If the box weight of the `prev_index` line of `walker_box` is 0, update `prev_index`
    /// randomly again.
    fn get_prev_index(&mut self) -> usize {
        let mut rng = rand::thread_rng();
        loop {
            if self.prev_index == self.state_space.len() {
                self.prev_index = rng.gen::<usize>() % self.state_space.len();
            }
            if self.walker_boxes[self.prev_index].max_weight == 0 {
                self.prev_index = rng.gen::<usize>() % self.state_space.len();
            } else {
                break;
            }
        }
        self.prev_index
    }

    /// Initialize the index with the length of `state_space`.
    pub fn initialize(&mut self) {
        self.prev_index = self.state_space.len();
    }
}

#[cfg(test)]
mod markov_test {
    use crate::markov::MarkovModel;
    use crate::walkers_alias_method::WalkerBox;

    #[test]
    fn make_markov_model() {
        let actual = MarkovModel::from(vec!["すもも", "も", "もも", "も", "もも", "の", "うち"]);

        let expected = MarkovModel {
            state_space: vec!["うち", "すもも", "の", "も", "もも"],
            walker_boxes: vec![
                WalkerBox::new(vec![0, 1, 2, 3, 4], vec![0, 0, 0, 0, 0], 0),
                WalkerBox::new(vec![3, 3, 3, 3, 3], vec![1, 1, 1, 1, 1], 1),
                WalkerBox::new(vec![0, 0, 0, 0, 0], vec![1, 1, 1, 1, 1], 1),
                WalkerBox::new(vec![4, 4, 4, 4, 4], vec![4, 4, 4, 4, 4], 4),
                WalkerBox::new(vec![2, 3, 2, 2, 3], vec![4, 4, 4, 2, 4], 4),
            ],
            prev_index: 5,
        };

        assert_eq!(actual, expected)
    }
}
