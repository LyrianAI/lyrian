//! A module related to Markov chain and its model generation.

use rand::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, PartialEq)]
/// Markov model structure
pub struct MarkovModel<T> {
    /// The set of possible states of the model.
    state_space: Vec<T>,

    /// The transition probability table by Walker's Alias Method.
    ///
    /// The head value is the index corresponding to the state of `state_space`, and the tail
    /// is the probability weights of it.
    ///
    /// The type of the weights is [`usize`] to counter floating point arithmetic errors.
    wa_table: Vec<Vec<[(usize, usize); 2]>>,

    /// The index of the state generated by the previous [`next()`](#method.next)
    /// method. The initial value is the length of `state_space`.
    prev_index: usize,
}

impl<T> MarkovModel<T>
where
    T: Clone,
    T: Eq,
    T: Ord,
    T: PartialOrd,
    T: PartialEq,
{
    /// Creates a new instance of [`MarkovModel`].
    fn new(
        state_space: Vec<T>,
        wa_table: Vec<Vec<[(usize, usize); 2]>>,
        prev_index: usize,
    ) -> MarkovModel<T> {
        MarkovModel {
            state_space: state_space,
            wa_table: wa_table,
            prev_index: prev_index,
        }
    }

    /// Builds a new model from [`Vec<T>`].
    pub fn from(elements: Vec<T>) -> MarkovModel<T> {
        let mut state_space = elements.clone();
        state_space.sort();
        state_space.dedup();

        let space_len = state_space.len();

        let mut freq_table = vec![vec![0; space_len]; space_len];
        let mut prev_index: Option<usize> = None;
        for element in elements {
            let cur_index = state_space
                .iter()
                .position(|state| element == *state)
                .expect("There is no state that should exist.");
            if let Some(i) = prev_index {
                freq_table[i][cur_index] += 1;
            }
            prev_index = Some(cur_index);
        }

        let mut wa_table = vec![vec![[(0, 0); 2]; space_len]; space_len];

        for i in 0..space_len {
            let mut freq_tuples = Vec::new();
            let sum = freq_table[i].iter().fold(0, |acc, cur| acc + cur);
            for (i, freq) in freq_table[i].iter().enumerate() {
                freq_tuples.push((i, *freq * sum * space_len));
            }

            let mean = freq_tuples.iter().fold(0, |acc, cur| acc + cur.1) / freq_tuples.len();
            let mut below_vec = Vec::new();
            let mut above_vec = Vec::new();
            for tuple in &freq_tuples {
                if tuple.1 <= mean {
                    below_vec.push(*tuple);
                } else {
                    above_vec.push(*tuple)
                }
            }

            for j in 0..space_len {
                let below = below_vec.pop().unwrap();
                if let Some(above) = above_vec.pop() {
                    let diff = mean - below.1;
                    wa_table[i][j] = [(below.0, below.1), (above.0, diff)];
                    if above.1 - diff <= mean {
                        below_vec.push((above.0, above.1 - diff));
                    } else {
                        above_vec.push((above.0, above.1 - diff));
                    }
                } else {
                    wa_table[i][j][0] = (below.0, below.1);
                }
            }
        }

        MarkovModel::new(state_space, wa_table, space_len)
    }

    /// Returns the next possible state.
    ///
    /// The first state will be determined randomly, and the next one will be chosen
    /// by its state space.
    ///
    /// If you want to initialize the chain of states, use [`initialize()`](#method.initialize)
    /// methods.
    pub fn next(&mut self) -> &T {
        let elem_index = self.next_elem_index();
        self.prev_index = elem_index;
        self.state_space
            .get(elem_index)
            .expect("There is no state that should exist.")
    }

    /// Returns the index of the next output state.
    fn next_elem_index(&mut self) -> usize {
        let mut rng = rand::thread_rng();

        let row = self.prev_elem_index();
        let col = rng.gen::<usize>() % self.state_space.len();

        let max = self.box_weight(row);
        let r = rng.gen_range(0..max);
        if r < self.wa_table[row][col][0].1 {
            self.wa_table[row][col][0].0
        } else {
            self.wa_table[row][col][1].0
        }
    }

    /// Returns the index of the previous output state.
    ///
    /// If the value of `prev_index` is equal to the length of `state_space`, update it
    /// with a randomly generated value.
    ///
    /// If the box weight of the `prev_index` line of `wa_table` is 0, update `prev_index`
    /// randomly again.
    fn prev_elem_index(&mut self) -> usize {
        let mut rng = rand::thread_rng();
        loop {
            if self.prev_index == self.state_space.len() {
                self.prev_index = rng.gen::<usize>() % self.state_space.len();
            }
            if self.box_weight(self.prev_index) == 0 {
                self.prev_index = rng.gen::<usize>() % self.state_space.len();
            } else {
                break;
            }
        }
        self.prev_index
    }

    /// Returns the sum of the weights of the paired states in `wa_table`.
    fn box_weight(&self, row: usize) -> usize {
        self.wa_table[row][0][0].1 + self.wa_table[row][0][1].1
    }

    /// Initialize the index with the length of `state_space`.
    pub fn initialize(&mut self) {
        self.prev_index = self.state_space.len();
    }
}

#[cfg(test)]
mod markov_test {
    use crate::markov::MarkovModel;

    #[test]
    fn make_markov_model() {
        let actual = MarkovModel::from(vec!["すもも", "も", "もも", "も", "もも", "の", "うち"]);

        let expected = MarkovModel {
            state_space: vec!["うち", "すもも", "の", "も", "もも"],
            wa_table: vec![
                vec![
                    [(4, 0), (0, 0)],
                    [(3, 0), (0, 0)],
                    [(2, 0), (0, 0)],
                    [(1, 0), (0, 0)],
                    [(0, 0), (0, 0)],
                ],
                vec![
                    [(4, 0), (3, 1)],
                    [(2, 0), (3, 1)],
                    [(1, 0), (3, 1)],
                    [(0, 0), (3, 1)],
                    [(3, 1), (0, 0)],
                ],
                vec![
                    [(4, 0), (0, 1)],
                    [(3, 0), (0, 1)],
                    [(2, 0), (0, 1)],
                    [(1, 0), (0, 1)],
                    [(0, 1), (0, 0)],
                ],
                vec![
                    [(3, 0), (4, 4)],
                    [(2, 0), (4, 4)],
                    [(1, 0), (4, 4)],
                    [(0, 0), (4, 4)],
                    [(4, 4), (0, 0)],
                ],
                vec![
                    [(4, 0), (3, 4)],
                    [(1, 0), (3, 4)],
                    [(3, 2), (2, 2)],
                    [(0, 0), (2, 4)],
                    [(2, 4), (0, 0)],
                ],
            ],
            prev_index: 5,
        };

        assert_eq!(actual, expected)
    }
}
