//! A module related to Markov chain and its model generation.

use crate::walkers_alias_method::{WalkerBox, WalkerBoxBuilder};
use rand::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, PartialEq)]
/// Markov model structure
pub struct MarkovModel<T> {
    /// The set of possible states of the model.
    state_space: Vec<T>,

    /// The transition probability table by Walker's Alias Method.
    ///
    /// The head value is the index corresponding to the state of `state_space`, and the tail
    /// is the probability weights of it.
    ///
    /// The type of the weights is [`usize`] to counter floating point arithmetic errors.
    walker_boxes: Vec<WalkerBox>,

    /// The index of the state generated by the previous [`next()`](#method.next)
    /// method. The initial value is the length of `state_space`.
    prev_index: usize,
}

impl<T> MarkovModel<T>
where
    T: Clone,
    T: Eq,
    T: Ord,
    T: PartialOrd,
    T: PartialEq,
{
    /// Creates a new instance of [`MarkovModel`].
    fn new(state_space: Vec<T>, walker_boxes: Vec<WalkerBox>, prev_index: usize) -> MarkovModel<T> {
        MarkovModel {
            state_space: state_space,
            walker_boxes: walker_boxes,
            prev_index: prev_index,
        }
    }

    /// Builds a new model from [`Vec<T>`].
    pub fn from(elements: Vec<T>) -> MarkovModel<T> {
        let mut state_space = elements.clone();
        state_space.sort();
        state_space.dedup();

        let space_len = state_space.len();

        let mut freq_table = vec![vec![0; space_len]; space_len];
        let mut prev_index: Option<usize> = None;
        for element in elements {
            let cur_index = state_space
                .iter()
                .position(|state| element == *state)
                .expect("There is no state that should exist.");
            if let Some(i) = prev_index {
                freq_table[i][cur_index] += 1;
            }
            prev_index = Some(cur_index);
        }

        let mut walker_boxes = Vec::new();
        for row in freq_table {
            let mut builder = WalkerBoxBuilder::new(row);
            walker_boxes.push(builder.build());
        }

        MarkovModel::new(state_space, walker_boxes, space_len)
    }

    /// Returns the next possible state.
    ///
    /// The first state will be determined randomly, and the next one will be chosen
    /// by its state space.
    ///
    /// If you want to initialize the chain of states, use [`initialize()`](#method.initialize)
    /// methods.
    pub fn next(&mut self) -> &T {
        let elem_index = self.next_elem_index();
        self.prev_index = elem_index;
        self.state_space
            .get(elem_index)
            .expect("There is no state that should exist.")
    }

    /// Returns the index of the next output state.
    fn next_elem_index(&mut self) -> usize {
        let row = self.get_prev_index();
        self.walker_boxes[row].next()
    }

    /// Returns the index of the previous output state.
    ///
    /// If the value of `prev_index` is equal to the length of `state_space`, update it
    /// with a randomly generated value.
    ///
    /// If the box weight of the `prev_index` line of `walker_box` is 0, update `prev_index`
    /// randomly again.
    fn get_prev_index(&mut self) -> usize {
        let mut rng = rand::thread_rng();
        loop {
            if self.prev_index == self.state_space.len() {
                self.prev_index = rng.gen::<usize>() % self.state_space.len();
            }
            if self.walker_boxes[self.prev_index].max_weight == 0 {
                self.prev_index = rng.gen::<usize>() % self.state_space.len();
            } else {
                break;
            }
        }
        self.prev_index
    }

    /// Initialize the index with the length of `state_space`.
    pub fn initialize(&mut self) {
        self.prev_index = self.state_space.len();
    }
}

#[cfg(test)]
mod markov_test {
    use crate::markov::MarkovModel;

    #[test]
    fn check_convergence_in_probability() {
        let mut markov_model = MarkovModel::from(vec!["りんご", "と", "ばなな", "と", "りんご"]);

        const N: usize = 100_000;
        const P: f32 = 0.25;
        const EXPT: f32 = N as f32 * P;

        let mut elements = [""; N];
        for j in 0..N {
            elements[j] = markov_model.next();
        }

        let a = elements
            .iter()
            .fold(0, |acc, cur| if *cur == "りんご" { acc + 1 } else { acc })
            as f32;
        let b = elements
            .iter()
            .fold(0, |acc, cur| if *cur == "ばなな" { acc + 1 } else { acc })
            as f32;

        assert!((EXPT * 0.95 < a && a < EXPT * 1.05) && (EXPT * 0.95 < b && b < EXPT * 1.05))
    }
}
